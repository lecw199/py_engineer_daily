
**python垃圾回收采用引用计数为主，代式回收与标记-清除为辅的策略。**
参考：https://www.cnblogs.com/pinganzi/p/6646742.html
参考：https://blog.csdn.net/xiongchengluo1129/article/details/80462651 
参考：http://blog.sina.com.cn/s/blog_179876ce10102yd22.html

## 1、引用计数
python引用计数垃圾回收是George-Collins在1960年发明的。
每个对象都开一个属性记录引用次数，若引用次数为零，则自动释放该空间。

### 引用计数优缺点
```
引用计数机制的优点：

简单有效
实时性：一旦没有引用，内存就直接释放了。

引用计数机制的缺点：

维护引用计数消耗资源（例如：1、每个对象都多开空间记录引用次数；2、重新赋值或者数组、字典pop出对象等操作每次都先计算引用次数）
无法解决循环引用问题
```

### 引用计数增减情况例举
```
当发生以下四种情况的时候，该对象的引用计数器+1

对象被创建  a=14
对象被引用  b=a
对象被作为参数,传到函数中   func(a)
对象作为一个元素，存储在容器中   List={a,”a”,”b”,2}
  与上述情况相对应，当发生以下四种情况时，该对象的引用计数器-1

当该对象的别名被显式销毁时  del a
当该对象的引别名被赋予新的对象，   a=26
一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
将该元素从容器中删除时，或者容器被销毁时。
```


```python
#  del x 并不直接调用 x.__del__() --- 前者会将 x 的引用计数减一，而后者仅会在 x 的引用计数变为零时被调用。
import gc

gc.disable()

class T:
    def __del__(self):
        print ('xxx')
        
t = T()
t = 1

```

    xxx


## 标记-清除

* 基础概念
```
『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。
```

* 对象
```
标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。
```

* 流程
```
1.寻找根对象的集合，根对象就是一些全局引用和函数栈中的引用；2.从根对象集合出发，沿着根对象集合中的每一个引用，如果能达到某个对象A，则A称为可到达的，可到达的对象不可被删除，这就是垃圾检测阶段；3.当垃圾检测结束后，所有的对象分为了可到达的和不可到达的两部分，可到达的要予以保留，而不可到达的对象所占用的内存将被回收，这就是垃圾回收阶段。这就是标记-清除的大致工作流程。
```

* 缺点
```
这种垃圾收集机制所带来的额外操作实际上与系统中总的内存块的数量是相关的,当需要回收的内存块越多时,垃圾检测带来的额外操作就越多,而垃圾回收带来的额外操作就越少;反之,当需回收的内存块越少时,垃圾检测就将比垃圾回收带来更少的额外操作.为了提高垃圾收集的效率,采用"空间换时间的策略".
```

## 分代回收

* 背景
```
一系列的研究表明:无论使用何种语言开发,无论开发的是何种类型,何种规模的程序,都存在这样一点相同之处.即:一定比例的内存块的生存周期都比较短,通常是几百万条机器指令的时间,而剩下的内存块,起生存周期比较长,甚至会从程序开始一直持续到程序结束.
```

* 原理
```
将系统中的所有内存块根据其存活时间划分为不同的集合,每一个集合就成为一个"代",垃圾收集的频率随着"代"的存活时间的增大而减小.也就是说,活得越长的对象,就越不可能是垃圾,就应该减少对它的垃圾收集频率.那么如何来衡量这个存活时间:通常是利用几次垃圾收集动作来衡量,如果一个对象经过的垃圾收集次数越多,可以得出:该对象存活时间就越长.
```


```python
# 分三代，越往上回收频率越低
import gc
print (gc.get_threshold())
```

    (700, 10, 10)

